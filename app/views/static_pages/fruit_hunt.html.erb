<body>
</body>
<script src="http://gamingJS.com/Three.js"></script>
<script src="http://gamingJS.com/Tween.js"></script>
<script src="http://gamingJS.com/ChromeFixes.js"></script>
<script src="http://gamingJS.com/Scoreboard.js"></script>
<script src="http://gamingJS.com/Sounds.js"></script>
<script>
  // This is where stuff in our game will happen:
  var scene = new THREE.Scene();

  // This is what sees the stuff:
  var aspect_ratio = window.innerWidth / window.innerHeight;
  var camera = new THREE.PerspectiveCamera(75, aspect_ratio, 1, 10000);
  camera.position.z = 500;
  

  // This will draw what the camera sees onto the screen:
  var renderer = new THREE.CanvasRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ******** START CODING ON THE NEXT LINE ********
  
  var not_allowed = [];
  
  var marker = new THREE.Object3D(); 
  scene.add(marker);
  
  var scoreboard = new Scoreboard(); scoreboard.countdown(45); scoreboard.score(); scoreboard.help(
 
'Arrow keys to move. ' +
'Space bar to jump for fruit. ' +
'Watch for shaking trees with fruit.' +
'Get near the tree and jump before the fruit is gone!'
);

var game_over = false; scoreboard.onTimeExpired(function() {
scoreboard.message("Game Over!");
        game_over = true;
      });
  
  var cover = new THREE.MeshPhongMaterial({color: 0xFF9900});
  var body = new THREE.SphereGeometry(100,20,20); 
  var avatar = new THREE.Mesh(body, cover);
  marker.add(avatar);
  
  
  
  var hand = new THREE.SphereGeometry(50,20,20);
  var right_hand = new THREE.Mesh(hand, cover); 
  right_hand.position.set(-150, 0, 0); 
  avatar.add(right_hand);

  var left_hand = new THREE.Mesh(hand, cover);
  left_hand.position.set(150, 0, 0);
  avatar.add(left_hand);

  var foot = new THREE.SphereGeometry(50,20,20);
  var right_foot = new THREE.Mesh(foot, cover);
  var left_foot = new THREE.Mesh(foot, cover); 
  right_foot.position.set(70,-125,0);
  left_foot.position.set(-70,-125,0);
  avatar.add(right_foot);
  avatar.add(left_foot);
  
  
  var spear = new THREE.CylinderGeometry(5,5,300);
  var spear_mesh = new THREE.Mesh(spear, cover);
  spear_mesh.position.set(0,0,0);
  left_hand.add(spear_mesh);
  
  var speartop = new THREE.CylinderGeometry(1,15,20);
  var speartop_mesh = new THREE.Mesh(speartop, cover);
  speartop_mesh.position.set(0,160,0);
  spear_mesh.add(speartop_mesh);
 
  marker.add(camera); 
 
 
  var tree_with_treasure;
  var trees = [];
 trees.push(makeTreeAt( 500, 0)); 
 trees.push(makeTreeAt(-500, 0));
 trees.push(makeTreeAt( 750, -1000));
 trees.push(makeTreeAt(-750, -1000));
 
 var ground = new THREE.Mesh( new THREE.PlaneGeometry(3000,3000,100,100),
    new THREE.MeshNormalMaterial() );
    ground.position.y = -200;
    ground.rotation.x = -Math.PI/2;
     ground.position.z =-700
    scene.add(ground);
 
 
 function makeTreeAt(x, z) { var trunk = new THREE.Mesh(
  new THREE.CylinderGeometry(50, 50, 200),
  new THREE.MeshBasicMaterial({color: 0xA0522D}) );
  var top = new THREE.Mesh(
  new THREE.SphereGeometry(150),
  new THREE.MeshBasicMaterial({color: 0x228B22}) );
    
    var boundary = new THREE.Mesh( new THREE.CircleGeometry(300),
    new THREE.MeshNormalMaterial() );
    boundary.position.y = -100;
    boundary.rotation.x = -Math.PI/2;
    trunk.add(boundary);
    not_allowed.push(boundary);
    top.position.y = 175;
    trunk.add(top);
    trunk.position.set(x, -75, z);
    scene.add(trunk);
    return top;
}


function walk(){
  if (!isWalking()) return;
  var position = Math.sin(clock.getElapsedTime()*10) * 100;
     right_hand.position.z = position;
     left_hand.position.z = -position;
     right_foot.position.z = position;
     left_foot.position.z = -position;
}
function turn() {
var direction = 0;
if (is_moving_forward) direction = Math.PI; 
if (is_moving_back) direction = 0;
if (is_moving_right) direction = Math.PI/2; 
if (is_moving_left) direction = -Math.PI/2;
  avatar.rotation.y = direction;
}

function acrobatics(){
  if (is_cartwheeling) {
    avatar.rotation.z = avatar.rotation.z + 0.05;
  }
  
  if (is_flipping){
    avatar.rotation.x += 0.05;
    avatar.rotation.y += 0.05;
  }  
}
 
 var is_cartwheeling = false;
 var is_flipping = false;
var clock = new THREE.Clock(true);

function animate() {
 walk();
 turn();
 acrobatics();
requestAnimationFrame(animate); 
TWEEN.update();
  renderer.render(scene, camera);
}
animate();

var is_moving_right, is_moving_left, is_moving_forward, is_moving_back;

function isWalking() {
  if (is_moving_right) return true;
  if (is_moving_left) return true;
  if (is_moving_forward) return true;
  if (is_moving_back) return true;
  return false;
}


document.addEventListener('keydown', function(event) {
var code = event.keyCode;
if (code == 37){
  marker.position.x = marker.position.x - 50; // left
  is_moving_left = true;
} 
if (code == 38){
   marker.position.z = marker.position.z-50; // forward
   is_moving_forward = true;
}
if (code == 39){
   marker.position.x = marker.position.x+50; // right
   is_moving_right = true;
}
if (code == 40){
   marker.position.z = marker.position.z+50; // backward
   is_moving_back = true;
}

if (code == 67) is_cartwheeling = !is_cartwheeling; //C key
if (code == 70) is_flipping = !is_flipping; //F key
if (code == 82) avatar.rotation.set(0,0,0); //R key
if (code == 32){
  if (marker.position.y < 3){
    jump(); //space
    // Sounds.spring.play();
  }
} 


if (detectCollisions()) {
  if (is_moving_left) marker.position.x = marker.position.x+50;
  if (is_moving_right) marker.position.x = marker.position.x-50;
  if (is_moving_forward) marker.position.z = marker.position.z+50;
  if (is_moving_back) marker.position.z = marker.position.z-50;
}

});

function reset(){
   right_hand.position.z = 0;
  left_hand.position.z = 0;
  right_foot.position.z = 0; 
  left_foot.position.z = 0;
}

document.addEventListener('keyup', function(event) { 
  var code = event.keyCode;
if (code == 37) {
  is_moving_left = false;
  reset();
}
if (code == 38){
   is_moving_forward = false;
   reset();
}
if (code == 39){
   is_moving_right = false;
   reset();
}
if (code == 40){
   is_moving_back = false;
   reset();
}
});

function detectCollisions() {
var vector = new THREE.Vector3(0, -1, 0);
var ray = new THREE.Ray(marker.position, vector);
var intersects = ray.intersectObjects(not_allowed);
if (intersects.length > 0) return true;
return false;
}

function shakeTree() {
tree_with_treasure = Math.floor(Math.random() * trees.length);
new TWEEN
.Tween({x: 0})
.to({x: 2*Math.PI}, 300)
.repeat(20) 
.onUpdate(function () {
      trees[tree_with_treasure].position.x = 25 * Math.sin(this.x);
    })
.start();
  setTimeout(shakeTree, 12*1000);
}
shakeTree();

function reset_tree(){
  tree_with_treasure = undefined;
}

function jump() { 
    checkForTreasure();
    // console.log(tree_with_treasure);
        animateJump();
      }

function checkForTreasure() {
  if (tree_with_treasure == undefined) return;
  var treasure_tree = trees[tree_with_treasure], p1 = treasure_tree.parent.position,
  p2 = marker.position;
  var distance = Math.sqrt(
  (p1.x - p2.x)*(p1.x - p2.x) +
            (p1.z - p2.z)*(p1.z - p2.z)
          );
  if (distance < 500) {
            scorePoints();
          }
}


function scorePoints() {
if (scoreboard.getTimeRemaining() === 0) return;
  scoreboard.addPoints(10);
// Sounds.guitar.play();
animateFruit();
}

var fruit;
function animateFruit() {
if (fruit) return;

fruit = new THREE.Mesh(
new THREE.CylinderGeometry(25, 25, 5, 25),
new THREE.MeshBasicMaterial({color: 0xFFD700}) );
  fruit.rotation.x = Math.PI/2;
  marker.add(fruit);
new TWEEN. Tween({
height: 150,
spin: 0 }).
    to({
      height: 250,
      spin: 4
}, 500). onUpdate(function () {
      fruit.position.y = this.height;
      fruit.rotation.z = this.spin;
    }).
onComplete(function() { marker.remove(fruit); fruit = undefined;
}).
start();
}

function animateJump() { new TWEEN
.Tween({jump: 0}) 
.to({jump: Math.PI}, 500) 
.onUpdate(function () {
      marker.position.y = 200* Math.sin(this.jump);
    })
.start(); }

</script>

